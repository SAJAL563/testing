<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Player</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            height: 100%;
            background: linear-gradient(135deg, #1a0033, #330066);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video {
            width: 90%;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <video id="videoPlayer" controls></video>

    <script>
        const proxyUrl = "https://cors-proxy-fawn.vercel.app/proxy?url=";
        const originalM3U8Url = "https://cors-proxy-fawn.vercel.app/proxy?url=https://d27h84tpitp9e0.cloudfront.net/ivs/v1/916749774596/cv7OeduHYcU8/2025/1/15/7/11/sRjo9dMRool0/media/hls/1080p60/playlist_vod.m3u8";

        class HLSPlayer {
            constructor(videoElement) {
                this.video = videoElement;
                this.mediaSource = new MediaSource();
                this.sourceBuffer = null;
                this.segments = new Set();
                this.pendingSegments = [];
                this.isUpdating = false;
                this.baseUrl = '';

                this.video.src = URL.createObjectURL(this.mediaSource);
                this.mediaSource.addEventListener('sourceopen', () => this.onSourceOpen());
            }

            async onSourceOpen() {
                this.sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                this.sourceBuffer.mode = 'segments';
                this.sourceBuffer.addEventListener('updateend', () => this.onUpdateEnd());
                await this.initializePlaylist();
            }

            async initializePlaylist() {
                try {
                    const playlist = await this.fetchPlaylist();
                    this.baseUrl = this.getBaseUrl();
                    const segments = this.parsePlaylist(playlist);
                    await this.loadInitialSegments(segments);
                } catch (error) {
                    console.error('Error initializing playlist:', error);
                }
            }

            async fetchPlaylist() {
                const response = await fetch(originalM3U8Url);
                return await response.text();
            }

            getBaseUrl() {
                return originalM3U8Url.match(/.+\//)[0];
            }

            parsePlaylist(playlist) {
                const lines = playlist.split('\n');
                const segments = [];
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].endsWith('.ts')) {
                        segments.push(lines[i]);
                    }
                }
                return segments;
            }

            async loadInitialSegments(segments) {
                for (const segment of segments) {
                    if (!this.segments.has(segment)) {
                        this.segments.add(segment);
                        await this.fetchAndAppendSegment(segment);
                    }
                }
            }

            async fetchAndAppendSegment(segmentUrl) {
                try {
                    const fullUrl = `${proxyUrl}${this.baseUrl}${segmentUrl}`;
                    const response = await fetch(fullUrl);
                    const data = await response.arrayBuffer();
                    
                    if (this.sourceBuffer.updating) {
                        this.pendingSegments.push(data);
                    } else {
                        this.appendSegment(data);
                    }
                } catch (error) {
                    console.error('Error fetching segment:', error);
                }
            }

            appendSegment(data) {
                try {
                    this.sourceBuffer.appendBuffer(data);
                } catch (error) {
                    console.error('Error appending segment:', error);
                }
            }

            onUpdateEnd() {
                this.isUpdating = false;
                if (this.pendingSegments.length > 0) {
                    const nextSegment = this.pendingSegments.shift();
                    this.appendSegment(nextSegment);
                }
            }

            async checkForNewSegments() {
                try {
                    const playlist = await this.fetchPlaylist();
                    const newSegments = this.parsePlaylist(playlist);
                    
                    for (const segment of newSegments) {
                        if (!this.segments.has(segment)) {
                            this.segments.add(segment);
                            await this.fetchAndAppendSegment(segment);
                        }
                    }
                } catch (error) {
                    console.error('Error checking for new segments:', error);
                }
            }
        }

        // Initialize the player
        const video = document.getElementById('videoPlayer');
        const player = new HLSPlayer(video);

        // Periodically check for new segments
        setInterval(() => {
            player.checkForNewSegments();
        }, 10000);
    </script>
</body>
</html>
