<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Player</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/plyr/3.7.8/plyr.css" />
    <style>
        body, html {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            height: 100%;
            background: linear-gradient(135deg, #1a0033, #330066);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .video-container {
            width: 90%;
            max-width: 1280px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .plyr {
            width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="video-container">
        <video id="videoPlayer"></video>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/plyr/3.7.8/plyr.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        const proxyUrl = "https://cors-proxy-fawn.vercel.app/proxy?url=";
        const originalM3U8Url = "https://cors-proxy-fawn.vercel.app/proxy?url=https://d27h84tpitp9e0.cloudfront.net/ivs/v1/916749774596/cv7OeduHYcU8/2025/1/15/7/11/sRjo9dMRool0/media/hls/1080p60/playlist_vod.m3u8";

        let modifiedPlaylist = "";
        let masterPlaylist = "";
        let currentSegments = new Set();
        let hls = null;

        // Initialize Plyr
        const player = new Plyr('#videoPlayer', {
            controls: [
                'play-large',
                'play',
                'progress',
                'current-time',
                'duration',
                'mute',
                'volume',
                'settings',
                'fullscreen'
            ]
        });

        async function fetchAndStoreM3U8(url, isInitial = false) {
            try {
                const response = await fetch(url);
                const playlist = await response.text();
                const baseUrl = url.match(/.+\//)[0];

                if (isInitial) {
                    // Store the master playlist structure
                    masterPlaylist = playlist.split('\n')
                        .filter(line => line.startsWith('#'))
                        .join('\n');
                }

                // Extract new segments
                const newSegments = [];
                const lines = playlist.split('\n');
                for (const line of lines) {
                    if (line.endsWith('.ts') && !currentSegments.has(line)) {
                        currentSegments.add(line);
                        const fullTsUrl = `${baseUrl}${line}`;
                        newSegments.push(`${proxyUrl}${encodeURIComponent(fullTsUrl)}`);
                    }
                }

                // Add new segments to modified playlist
                if (newSegments.length > 0) {
                    modifiedPlaylist += '\n' + newSegments.join('\n');
                }

                // Combine master playlist structure with segments
                const finalPlaylist = `${masterPlaylist}\n${modifiedPlaylist}`;
                
                // Create blob and return URL
                const blob = new Blob([finalPlaylist], { type: 'application/x-mpegURL' });
                return URL.createObjectURL(blob);

            } catch (error) {
                console.error("Error fetching or modifying the M3U8 playlist:", error);
                return null;
            }
        }

        let updateInterval = null;

        function initializePlayer(url) {
            if (Hls.isSupported()) {
                if (hls) {
                    hls.destroy();
                }

                hls = new Hls({
                    maxBufferLength: 30,
                    maxMaxBufferLength: 600,
                    maxBufferSize: 60 * 1000 * 1000,
                    maxBufferHole: 0.5,
                    highBufferWatchdogPeriod: 2,
                    nudgeOffset: 0.1,
                    nudgeMaxRetry: 5,
                    maxFragLookUpTolerance: 0.25,
                    liveSyncDurationCount: 3,
                    enableWorker: true,
                    startLevel: -1,
                    debug: false
                });

                const video = player.media;
                hls.attachMedia(video);

                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    console.log('HLS media attached');
                    hls.loadSource(url);

                    // Start update interval only after initial load
                    if (!updateInterval) {
                        updateInterval = setInterval(updatePlaylist, 10000);
                    }
                });

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS manifest parsed');
                    video.play().catch(() => {
                        console.log("Autoplay prevented");
                    });
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                        }
                    }
                });
            }
        }

        async function updatePlaylist() {
            if (!hls) return;

            const currentTime = player.media.currentTime;
            const wasPlaying = !player.media.paused;
            
            const newUrl = await fetchAndStoreM3U8(originalM3U8Url);
            if (newUrl) {
                // Instead of loading a new source, append segments to the existing playlist
                hls.trigger(Hls.Events.LEVEL_UPDATED, {
                    details: {
                        fragments: Array.from(currentSegments).map(segment => ({
                            url: segment,
                            start: currentTime,
                            duration: 2  // Assuming 2-second segments
                        }))
                    }
                });
            }
        }

        // Start the player
        fetchAndStoreM3U8(originalM3U8Url, true).then(localUrl => {
            if (localUrl) {
                initializePlayer(localUrl);
            }
        });

        // Cleanup
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            if (hls) {
                hls.destroy();
            }
            player.destroy();
        });
    </script>
</body>
</html>
